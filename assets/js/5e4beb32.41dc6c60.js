"use strict";(globalThis.webpackChunkai_robotics_textbook=globalThis.webpackChunkai_robotics_textbook||[]).push([[4873],{237:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"module-2/building-ros-applications","title":"Building Robot Applications with ROS Packages","description":"Learn how to build and integrate ROS packages to create robust, modular robot applications.","source":"@site/docs/module-2/08-building-ros-applications.md","sourceDirName":"module-2","slug":"/module-2/building-ros-applications","permalink":"/hackathon_spec_kit_book/docs/module-2/building-ros-applications","draft":false,"unlisted":false,"tags":[{"inline":true,"label":"ros","permalink":"/hackathon_spec_kit_book/docs/tags/ros"},{"inline":true,"label":"packages","permalink":"/hackathon_spec_kit_book/docs/tags/packages"},{"inline":true,"label":"building","permalink":"/hackathon_spec_kit_book/docs/tags/building"},{"inline":true,"label":"robot","permalink":"/hackathon_spec_kit_book/docs/tags/robot"},{"inline":true,"label":"applications","permalink":"/hackathon_spec_kit_book/docs/tags/applications"}],"version":"current","lastUpdatedAt":1765144290000,"sidebarPosition":8,"frontMatter":{"title":"Building Robot Applications with ROS Packages","slug":"building-ros-applications","sidebar_position":8,"description":"Learn how to build and integrate ROS packages to create robust, modular robot applications.","tags":["ros","packages","building","robot","applications"]},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 in Depth: Nodes, Topics, Services, Actions","permalink":"/hackathon_spec_kit_book/docs/module-2/ros2-in-depth"},"next":{"title":"URDF & XACRO for Robot Modeling","permalink":"/hackathon_spec_kit_book/docs/module-2/urdf-xacro-modeling"}}');var s=i(4848),t=i(8453);const r={title:"Building Robot Applications with ROS Packages",slug:"building-ros-applications",sidebar_position:8,description:"Learn how to build and integrate ROS packages to create robust, modular robot applications.",tags:["ros","packages","building","robot","applications"]},o=void 0,c={},l=[{value:"Summary",id:"summary",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Main Content",id:"main-content",level:2},{value:"Understanding ROS Packages",id:"understanding-ros-packages",level:3},{value:"ROS Package Structure",id:"ros-package-structure",level:4},{value:"Creating a Custom ROS Package",id:"creating-a-custom-ros-package",level:4},{value:"Developing ROS Nodes and Publishers/Subscribers",id:"developing-ros-nodes-and-publisherssubscribers",level:3},{value:"The ROS Build System: Catkin",id:"the-ros-build-system-catkin",level:3},{value:"Integrating ROS Packages",id:"integrating-ros-packages",level:3},{value:"Designing Modular ROS Architectures",id:"designing-modular-ros-architectures",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Glossary",id:"glossary",level:2},{value:"Review Questions",id:"review-questions",level:2}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"This chapter delves into the process of building robot applications using ROS (Robot Operating System) packages. ROS is a powerful open-source framework that enables the development of complex robotic systems through a modular, distributed architecture. In this chapter, you will learn how to create, customize, and integrate ROS packages to construct versatile and scalable robot applications. You will explore the structure and components of ROS packages, understand the ROS build system, and gain hands-on experience in developing and deploying ROS-based robot applications."}),"\n",(0,s.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Explain the key components and structure of a ROS package"}),"\n",(0,s.jsx)(n.li,{children:"Implement a custom ROS package with publisher and subscriber nodes"}),"\n",(0,s.jsx)(n.li,{children:"Analyze the ROS build system and use catkin to build and deploy ROS packages"}),"\n",(0,s.jsx)(n.li,{children:"Evaluate the integration of multiple ROS packages to create a comprehensive robot application"}),"\n",(0,s.jsx)(n.li,{children:"Design a modular ROS-based system architecture for a complex robot application"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Familiarity with the ROS 2 framework and its core concepts, as covered in previous chapters"}),"\n",(0,s.jsx)(n.li,{children:"Basic understanding of Python programming and its application in ROS"}),"\n",(0,s.jsx)(n.li,{children:"Experience with version control systems, such as Git, for managing ROS package development"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"main-content",children:"Main Content"}),"\n",(0,s.jsx)(n.h3,{id:"understanding-ros-packages",children:"Understanding ROS Packages"}),"\n",(0,s.jsx)(n.p,{children:"ROS packages are the fundamental building blocks of ROS-based robot applications. A ROS package is a directory structure that contains all the necessary files and resources required to implement a specific functionality or component of a robotic system. Packages can include code, configuration files, launch scripts, and various other assets. Understanding the structure and components of ROS packages is crucial for effectively building and integrating them into your robot applications."}),"\n",(0,s.jsx)(n.h4,{id:"ros-package-structure",children:"ROS Package Structure"}),"\n",(0,s.jsx)(n.p,{children:"A typical ROS package directory structure includes the following key elements:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"package.xml"}),": This XML file contains metadata about the package, such as its name, version, description, and dependencies."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CMakeLists.txt"}),": This file is used by the ROS build system (catkin) to manage the compilation and installation of the package."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"src/"}),": This directory holds the source code files for the package, typically written in C++ or Python."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"include/"}),": This directory contains any header files or other include files used by the package's source code."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"launch/"}),": This directory stores launch files, which are used to start and configure the ROS nodes that make up the package."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"config/"}),": This directory holds any configuration files, such as parameter files, used by the package."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"scripts/"}),": This directory contains any executable scripts, such as Python scripts, that are part of the package."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"The specific structure of a ROS package may vary depending on the package's requirements, but the elements mentioned above are common across most ROS packages."})}),"\n",(0,s.jsx)(n.h4,{id:"creating-a-custom-ros-package",children:"Creating a Custom ROS Package"}),"\n",(0,s.jsxs)(n.p,{children:["To create a new ROS package, you can use the ",(0,s.jsx)(n.code,{children:"ros2 pkg create"})," command. This command generates the necessary directory structure and files for a new package. For example, to create a package named ",(0,s.jsx)(n.code,{children:"my_robot_package"}),", you would run the following command:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"ros2 pkg create my_robot_package --build-type ament_python --dependencies rclpy\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This command creates a new ROS package named ",(0,s.jsx)(n.code,{children:"my_robot_package"})," with the ",(0,s.jsx)(n.code,{children:"ament_python"})," build type and the ",(0,s.jsx)(n.code,{children:"rclpy"})," dependency."]}),"\n",(0,s.jsx)(n.h3,{id:"developing-ros-nodes-and-publisherssubscribers",children:"Developing ROS Nodes and Publishers/Subscribers"}),"\n",(0,s.jsx)(n.p,{children:"Within a ROS package, you can create ROS nodes that implement specific functionalities. These nodes can communicate with each other using the ROS publisher/subscriber model. Let's look at an example of creating a simple publisher and subscriber node in Python:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# my_robot_package/my_robot_package/publisher_node.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\n\r\nclass PublisherNode(Node):\r\n    def __init__(self):\r\n        super().__init__('publisher_node')\r\n        self.publisher_ = self.create_publisher(String, 'topic', 10)\r\n        self.timer = self.create_timer(0.5, self.timer_callback)\r\n\r\n    def timer_callback(self):\r\n        msg = String()\r\n        msg.data = 'Hello from the publisher!'\r\n        self.publisher_.publish(msg)\r\n        self.get_logger().info('Published: \"%s\"' % msg.data)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = PublisherNode()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# my_robot_package/my_robot_package/subscriber_node.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\n\r\nclass SubscriberNode(Node):\r\n    def __init__(self):\r\n        super().__init__('subscriber_node')\r\n        self.subscription = self.create_subscription(\r\n            String,\r\n            'topic',\r\n            self.listener_callback,\r\n            10)\r\n        self.subscription  # prevent unused variable warning\r\n\r\n    def listener_callback(self, msg):\r\n        self.get_logger().info('I heard: \"%s\"' % msg.data)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = SubscriberNode()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, the ",(0,s.jsx)(n.code,{children:"PublisherNode"})," creates a publisher that sends ",(0,s.jsx)(n.code,{children:"String"})," messages to the ",(0,s.jsx)(n.code,{children:"'topic'"})," topic every 0.5 seconds. The ",(0,s.jsx)(n.code,{children:"SubscriberNode"})," creates a subscriber that listens for messages on the ",(0,s.jsx)(n.code,{children:"'topic'"})," topic and logs the received messages."]}),"\n",(0,s.jsx)(n.h3,{id:"the-ros-build-system-catkin",children:"The ROS Build System: Catkin"}),"\n",(0,s.jsxs)(n.p,{children:["ROS uses the ",(0,s.jsx)(n.code,{children:"catkin"})," build system to manage the compilation and installation of ROS packages. The ",(0,s.jsx)(n.code,{children:"catkin"})," build system is responsible for resolving dependencies, compiling source code, and creating installable packages."]}),"\n",(0,s.jsxs)(n.p,{children:["The main steps in the ",(0,s.jsx)(n.code,{children:"catkin"})," build process are:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Catkin Workspace Setup"}),": Create a ",(0,s.jsx)(n.code,{children:"catkin"})," workspace directory and initialize it with the ",(0,s.jsx)(n.code,{children:"catkin init"})," command."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Package Development"}),": Develop your ROS packages within the ",(0,s.jsx)(n.code,{children:"catkin"})," workspace, following the package structure guidelines."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Catkin Build"}),": Use the ",(0,s.jsx)(n.code,{children:"catkin build"})," command to build the packages in your ",(0,s.jsx)(n.code,{children:"catkin"})," workspace."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Package Installation"}),": Install the built packages using the ",(0,s.jsx)(n.code,{children:"catkin install"})," command."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"catkin"})," build system is used in ROS 1, while ROS 2 uses the ",(0,s.jsx)(n.code,{children:"ament"})," build system, which has a similar structure and functionality."]})}),"\n",(0,s.jsx)(n.h3,{id:"integrating-ros-packages",children:"Integrating ROS Packages"}),"\n",(0,s.jsx)(n.p,{children:"One of the key benefits of ROS is its modular architecture, which allows you to easily integrate multiple ROS packages to create a comprehensive robot application. By leveraging the publisher/subscriber communication model and the ROS launch system, you can seamlessly combine different packages to build complex robotic systems."}),"\n",(0,s.jsx)(n.p,{children:"Here's an example of how you might integrate multiple ROS packages using a launch file:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"\x3c!-- my_robot_package/launch/my_robot_app.launch.py --\x3e\r\nfrom launch import LaunchDescription\r\nfrom launch_ros.actions import Node\r\n\r\ndef generate_launch_description():\r\n    return LaunchDescription([\r\n        Node(\r\n            package='my_robot_package',\r\n            executable='publisher_node',\r\n            name='publisher_node'\r\n        ),\r\n        Node(\r\n            package='another_package',\r\n            executable='subscriber_node',\r\n            name='subscriber_node'\r\n        )\r\n    ])\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, the launch file integrates the ",(0,s.jsx)(n.code,{children:"publisher_node"})," from the ",(0,s.jsx)(n.code,{children:"my_robot_package"})," package and the ",(0,s.jsx)(n.code,{children:"subscriber_node"})," from the ",(0,s.jsx)(n.code,{children:"another_package"})," package, allowing them to communicate with each other through the ROS topic system."]}),"\n",(0,s.jsx)(n.h3,{id:"designing-modular-ros-architectures",children:"Designing Modular ROS Architectures"}),"\n",(0,s.jsx)(n.p,{children:"When building complex robot applications, it's important to design a modular and scalable ROS-based system architecture. This involves breaking down the overall system into smaller, reusable components (ROS packages) that can be easily integrated and maintained."}),"\n",(0,s.jsx)(n.p,{children:"Here's an example of a modular ROS-based system architecture for a mobile robot application:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"graph LR\r\n    subgraph Mobile Robot Application\r\n        sensor_package -- Sensor Data --\x3e navigation_package\r\n        navigation_package -- Navigation Commands --\x3e control_package\r\n        control_package -- Motor Commands --\x3e hardware_interface_package\r\n        hardware_interface_package -- Sensor Feedback --\x3e sensor_package\r\n    end\n"})}),"\n",(0,s.jsx)(n.p,{children:"In this architecture, the robot application is composed of several ROS packages, each responsible for a specific functionality:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sensor_package"}),": Handles sensor data acquisition and preprocessing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"navigation_package"}),": Implements navigation algorithms and decision-making"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"control_package"}),": Translates navigation commands into motor commands"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"hardware_interface_package"}),": Provides an abstraction layer for interacting with the robot's hardware"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By designing a modular architecture like this, you can easily swap out or update individual components of the robot application without affecting the overall system."}),"\n",(0,s.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"ROS packages are the fundamental building blocks of ROS-based robot applications, providing a structured and modular way to develop and integrate robotic components."}),"\n",(0,s.jsxs)(n.li,{children:["Creating custom ROS packages involves understanding the package structure, including the ",(0,s.jsx)(n.code,{children:"package.xml"}),", ",(0,s.jsx)(n.code,{children:"CMakeLists.txt"}),", and various directories for source code, configuration, and launch files."]}),"\n",(0,s.jsx)(n.li,{children:"Developing ROS nodes and implementing the publisher/subscriber communication model is a core aspect of building ROS-based applications."}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"catkin"})," build system in ROS 1 (and the ",(0,s.jsx)(n.code,{children:"ament"})," build system in ROS 2) is responsible for managing the compilation and installation of ROS packages."]}),"\n",(0,s.jsx)(n.li,{children:"Integrating multiple ROS packages to create a comprehensive robot application leverages the modular and distributed architecture of ROS, allowing for scalable and maintainable systems."}),"\n",(0,s.jsx)(n.li,{children:"Designing a modular ROS-based system architecture is crucial for building complex robot applications that can be easily extended and updated over time."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"glossary",children:"Glossary"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ROS Package"}),": A directory structure that contains the necessary files and resources to implement a specific functionality or component of a robotic system."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ROS Node"}),": A process that performs a specific task or functionality within a ROS-based system."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Publisher/Subscriber Model"}),": A communication pattern in ROS where nodes can publish messages to a topic, and other nodes can subscribe to that topic to receive the messages."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Catkin"}),": The build system used in ROS 1 to manage the compilation and installation of ROS packages."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Ament"}),": The build system used in ROS 2, which serves a similar purpose to Catkin in ROS 1."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ROS Launch"}),": A system in ROS that allows you to start multiple ROS nodes and configure their parameters in a coordinated manner."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modular Architecture"}),": A design approach in which a system is composed of smaller, reusable components that can be easily integrated and maintained."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Explain the key components of a ROS package and their purpose."}),"\n",(0,s.jsx)(n.li,{children:"Implement a custom ROS package with a publisher node that sends sensor data and a subscriber node that receives and logs the data."}),"\n",(0,s.jsx)(n.li,{children:"Describe the main steps involved in the Catkin build process and how it is used to manage the compilation and installation of ROS packages."}),"\n",(0,s.jsx)(n.li,{children:"Analyze the benefits of a modular ROS-based system architecture and provide an example of how you would design such an architecture for a mobile robot application."}),"\n",(0,s.jsx)(n.li,{children:"Evaluate the importance of integrating multiple ROS packages to create a comprehensive robot application and discuss the challenges and strategies involved in this process."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var a=i(6540);const s={},t=a.createContext(s);function r(e){const n=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);